<!DOCTYPE html>
<html lang="en">
<html>
<head>
	<meta charset="utf-8">
	<title>Game Animation</title>
	<script src="../d3.v4.min.js"></script>
	<link rel="stylesheet" type="text/css" href="game-animation.css">
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
</head>
<body style="padding: 40px;">
	<div class="container">
		<svg id="rink"></svg>
		<div style="border-top: 1px solid rgba(255, 255, 255, 0.2); padding-top: 9px; position: relative;">
			<div class="away header">
				<span class="abbr">AWAY</span
				><span class="score">0</span>
			</div
			><div class="home header">
				<span class="score">0</span
				><span class="abbr">HOME</span>
			</div>
			<div class="shot-tallies">
				<div class="away">
				</div>
				<div class="home">
				</div>
			</div>
			<svg id="clock">
				<defs>
					<clipPath id="cp-clock"></clipPath>
				</defs>
			</svg>
			<span id="period" style="opacity: 0.6;">1</span>
		</div>
	</div>
	<button style="margin: 20px 0; display: none;" onclick="animateGame();">Start animation</button>
	<p style="color: #fff;">Cover the magenta outline with the screen recorder's dashed border.</p>
</body>
<script>

//
// Inputs
// 

var gameId = 2016070111;
var colour = ["blue", "red"];	// Colour class for away/home
var isRegularSeason = true;

//
// Data variables
//

var jsonUrl = "https://statsapi.web.nhl.com/api/v1/game/" + gameId + "/feed/live";
var teamData;
var shotData;
var periodDurations; // Play time for each period â€” in OT, goals will end play early
var maxPeriodDurations;

//
// Layout variables
//

var h = 120;
var w = 240;
var margin = { top: 0, right: 10, bottom: 0, left: 10 };
var barrierL = 60;						// Length of goalie and skater barriers
var y = h/2;							// Center of nets, goalie barriers, skater barriers
var netX = 25;							// Net's x-offset from svg edges
var goalieX = 40;						// Goalie barrier's x-offset from svg edges
var skaterX = 55;						// Skater barrier's x-offset from svg edges

//
// Clock variables
//

var tau = 2 * Math.PI;
var arc = d3.arc()
	.innerRadius(12)
	.outerRadius(14);

//
// Header variables
//

var score = [0, 0];

//
// Prepare data
//

d3.json(jsonUrl, function(error, json) {
	if (error) {
		console.log(error);
		return;
	}

	// Store team and shot data
	teamData = [{
		abbr: json.gameData.teams.away.abbreviation.toLowerCase(),
		name: json.gameData.teams.away.name.toLowerCase(),
		colour: colour[0],
		nx: netX,
		gx: goalieX,
		sx: skaterX,
		y: y
	}, {
		abbr: json.gameData.teams.home.abbreviation.toLowerCase(),
		name: json.gameData.teams.home.name.toLowerCase(),
		colour: colour[1],
		nx: w - netX,
		gx: w - goalieX,
		sx: w - skaterX,
		y: y
	}];
	shotData = json.liveData.plays.allPlays.filter(function(d) {
		return ["blocked_shot", "missed_shot", "shot", "goal"].indexOf(d.result.eventTypeId.toLowerCase()) >= 0;
	});
	shotData.forEach(function(d) {
		d.about.periodTime = jsonTimeToSecs(d.about.periodTime);
		// For blocked shots, update the team
		var type = d.result.eventTypeId.toLowerCase();
		var team = d.team.name.toLowerCase();
		if (type === "blocked_shot" && team === teamData[0].name) {
			 d.team.name = teamData[1].name.toLowerCase();
		} else if (type === "blocked_shot" && team === teamData[1].name) {
			 d.team.name = teamData[0].name.toLowerCase();
		}
	});

	// Store period durations
	var periodData = json.liveData.plays.allPlays.filter(function(d) {
		return ["period_end"].indexOf(d.result.eventTypeId.toLowerCase()) >= 0;
	});
	periodDurations = periodData.map(function(d) {
		return jsonTimeToSecs(d.about.periodTime);
	});

	// Store max period durations
	maxPeriodDurations = [20 * 60, 20 * 60, 20 * 60];
	if (isRegularSeason) {
		if (periodDurations.length > 3) {
			maxPeriodDurations.push([5 * 60]);
		}

		// If SO occurred, give it an artificial duration for the clock transitions to use
		if (periodDurations.length > 4) {
			periodDurations[4] = 180;
			maxPeriodDurations.push([180]);
		}
	}

	// Convert mm:ss to seconds
	function jsonTimeToSecs(timeStr) {
		var mins = parseInt(timeStr.substring(0, timeStr.indexOf(":")));
		var secs = parseInt(timeStr.substring(timeStr.indexOf(":") + 1));
		return 60 * mins + secs;
	}

	appendSvg();
});

//
// Append svg elements
//

function appendSvg() {

	//
	// Set team names and shot tally colours
	//

	d3.select(".away.header > .abbr").text(teamData[0].abbr);
	d3.select(".home.header > .abbr").text(teamData[1].abbr);
	d3.select(".away.header").attr("class", "away header " + teamData[0].colour);
	d3.select(".home.header").attr("class", "home header " + teamData[1].colour);
	d3.select(".shot-tallies > .away").attr("class", "away " + teamData[0].colour);
	d3.select(".shot-tallies > .home").attr("class", "home " + teamData[1].colour);

	//
	// Append clock
	//

	var clock = d3.select("#clock")
		.attr("width", 32)
		.attr("height", 32);
	// Append paths for period lengths
	 d3.select("#cp-clock").selectAll("path")
		.data(maxPeriodDurations.map(function(d, i) {
			var startElapsed = d3.sum(maxPeriodDurations.filter(function(p, j) { return j < i; }));
			var endElapsed = d3.sum(maxPeriodDurations.filter(function(p, j) { return j <= i; }));
			return {
				startAngle: (startElapsed / d3.sum(maxPeriodDurations)) * tau + 0.07,
				endAngle: (endElapsed / d3.sum(maxPeriodDurations)) * tau - 0.07,
				duration: d
			};
		}))
		.enter().append("path")
			.attr("d", arc)
			.style("fill", "#fff");

	// Append path for the total time
	clock.append("path")
		.datum({ startAngle: 0, endAngle: tau, duration: d3.sum(maxPeriodDurations) })
		.attr("d", arc)
		.attr("transform", "translate(16, 16)")
		.style("clip-path", "url(#cp-clock)");

	// Append path for the elapsed time
	clock.append("path")
		.datum({ startAngle: 0, endAngle: 0 * tau, duration: d3.sum(maxPeriodDurations) })
		.attr("id", "clock-elapsed")
		.attr("d", arc)
		.attr("transform", "translate(16, 16)")
		.style("clip-path", "url(#cp-clock)");
		

	//
	// Append rink elements
	//
	
	var svg = d3.select("#rink")
		.attr("width", w + margin.left + margin.right)
		.attr("height", h + margin.top + margin.bottom)
		.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	// Append goalie barrier
	svg.selectAll(".barrier-goalie")
		.data(teamData)
		.enter().append("line")
			.attr("class", function(d, i) {
				if (i === 0) {
					return "barrier-goalie away " + d.colour;
				} else {
					return "barrier-goalie home " + d.colour;
				}
			})
			.attr("x1", function(d) { return d.gx; })
			.attr("x2", function(d) { return d.gx; })
			.attr("y1", function(d) { return d.y - barrierL/2; })
			.attr("y2", function(d) { return d.y + barrierL/2; })

	// Append skater barrier
	svg.selectAll(".barrier-skater")
		.data(teamData)
		.enter().append("line")
			.attr("class", function(d, i) {
				if (i === 0) {
					return "barrier-skater away " + d.colour;
				} else {
					return "barrier-skater home " + d.colour;
				}
			})
			.attr("x1", function(d) { return d.sx; })
			.attr("x2", function(d) { return d.sx; })
			.attr("y1", function(d) { return d.y - barrierL/2; })
			.attr("y2", function(d) { return d.y + barrierL/2; })

	// Append group to hold shot elements
	var shotG = svg.append("g")
		.attr("class", "shots");

	// Append nets
	svg.selectAll("net")
		.data(teamData)
		.enter().append("path")
			.attr("class", function(d, i) {
				if (i === 0) {
					return "net away " + d.colour;
				} else {
					return "net home " + d.colour;
				}
			})
			.attr("d", function(d, i) {
				if (i === 0) {
					return "M" + teamData[0].nx + " " + y
						+ " L" + (teamData[0].nx - 12) + " " + (y - 8)
						+ " L" + (teamData[0].nx - 12) + " " + (y + 8)
						+ "Z";
				} else {
					return "M" + teamData[1].nx + " " + y
						+ " L" + (teamData[1].nx + 12) + " " + (y - 8)
						+ " L" + (teamData[1].nx + 12) + " " + (y + 8)
						+ "Z";				
				}
			});

	//
	// Generate and store shot paths
	//

	shotData.forEach(function(d) {
		var start = [];									// Where the shot starts
		var end = [];									// Where the shot ends
		var type = d.result.eventTypeId.toLowerCase();	// Shot type
		var team = d.team.name.toLowerCase(); 			// Team who took the shot

		// Get start and end points
		if (team === teamData[0].name) {
			start = [teamData[0].nx + 5, y];	// Shift shot start point to right to give some space between it and the net
			if (type === "goal") {
				end = [teamData[1].nx + 9, y];	// Shift shot end point to right to hit center of net
			} else if (type === "shot") {
				end[0] = teamData[1].gx;
				end[1] = y - (barrierL / 2) + (Math.random() * barrierL);
			} else if (type === "blocked_shot") {
				end[0] = teamData[1].sx;
				end[1] = y - (barrierL / 2) + (Math.random() * barrierL);
			} else if (type === "missed_shot") {
				end = [w + Math.random() * margin.right, Math.random() * h];
			}
		} else {
			start = [teamData[1].nx - 5, y];	// Shift shot start point to left to give some space between it and the net
			if (type === "goal") {
				end = [teamData[0].nx - 9, y];	// Shift shot end point to left to hit center of net
			} else if (type === "shot") {
				end[0] = teamData[0].gx;
				end[1] = y - (barrierL / 2) + (Math.random() * barrierL);
			} else if (type === "blocked_shot") {
				end[0] = teamData[0].sx;
				end[1] = y - (barrierL / 2) + (Math.random() * barrierL);
			} else if (type === "missed_shot") {
				end = [0 - Math.random() * margin.left, Math.random() * h];
			}
		}
		
		// Generate arc
		var end2 = [0, 0];
		end2[1] = Math.random() * (0.7 * h);						// Extent of y-deviation
		end2[1] = (Math.round(Math.random()) * 2 - 1) * end2[1];	// Randomize between positive and negative
		end2[1] = end2[1] + start[1];								// Add arc offset to original y value
		if (team === teamData[0].name) {
			end2[0] = start[0] + Math.random() * (end[0] - start[0]);
		} else {
			end2[0] = start[0] - Math.random() * (start[0] - end[0]);
		}

		d.path = "M" + start[0] + " " + start[1]
			+ " S" + end2[0] + " " + end2[1] + " " + end[0] + " " + end[1];
		d.end = end;
	});

	//
	// Append shot paths
	//

	shotG.selectAll("path.shot")
		.data(shotData)
		.enter().append("path")
			.attr("class", function(d) {
				var team = d.team.name.toLowerCase();
				if (team === teamData[0].name) {
					return "shot away " + teamData[0].colour;
				} else if (team === teamData[1].name) {
					return "shot home " + teamData[1].colour;
				}
			})
			.attr("d", function(d) {
				return d.path;
			})
			.style("stroke-opacity", 0);

	//
	// Append shot explosions
	//

	shotG.selectAll("circle.shot")
		.data(shotData)
		.enter().append("circle")
			.attr("class", function(d) {
				var team = d.team.name.toLowerCase();
				if (team === teamData[0].name) {
					return "shot away " + teamData[0].colour;
				} else if (team === teamData[1].name) {
					return "shot home " + teamData[1].colour;
				}
			})
			.attr("r", 0)
			.attr("cx", function(d) {
				return d.end[0];
			})
			.attr("cy", function(d) {
				return d.end[1];
			})
			.style("stroke-width", function(d) {
				var type = d.result.eventTypeId.toLowerCase();
				if (type === "goal") {
					return 8;
				} else {
					return 0;
				}
			});

	// Activate button to start animation
	d3.select("button")
		.style("display", "");
}

//
// Animate svg
//

function animateGame() {

	// Disable start button
	d3.select("button")
		.attr("disabled", "disabled");

	// Animate clock
	d3.select("#clock-elapsed").transition()
		.duration(function(d) { return (d.duration * 1000) / 200; })
		.ease(d3.easeLinear)
		.call(arcTween, (d3.sum(periodDurations) / d3.sum(maxPeriodDurations)) * tau);
	function arcTween(transition, newAngle) {
		transition.attrTween("d", function(d) {
			var interpolate = d3.interpolate(d.endAngle, newAngle);
			return function(t) {
				d.endAngle = interpolate(t);
				return arc(d);
			};
		});
	}

	// Animate period label
	var currentPeriod = 1;
	transitionPeriod();

	function transitionPeriod() {
		d3.select("#period").transition()
			.duration(10)
			.delay(function() {
				// Since SO is 0 seconds long, add a dummy 10ms delay
				// Without this dummy delay, the transition from SO to final won't happen
				return d3.max([0, maxPeriodDurations[currentPeriod - 1] * 1000 / 200]);
			})
			.style("opacity", 1)
			.ease(d3.easeQuadOut)
			.on("end", function() {
				currentPeriod++;

				// Update text
				if (currentPeriod <= periodDurations.length) {
					d3.select(this).text(currentPeriod);
				} else {
					d3.select(this).text("F");
				}

				// Fade text in
				d3.select(this).transition()
					.ease(d3.easeQuadIn)
					.duration(100)
					.style("opacity", 0.6);

				// Schedule the next transition
				if (currentPeriod <= periodDurations.length) {
					transitionPeriod();
				} else {
					endGame();
				}
			});
	}

	// Animate shot paths
	d3.selectAll("path.shot").transition()
		.duration(50)
		.delay(function(d) {
			var delay = d.about.periodTime;
			for (var i = 0; i < d.about.period - 1; i++) {
				delay += periodDurations[i];
			}
			return (delay * 1000) / 200;
		})
		.style("stroke-opacity", 0.5)
		.on("start", function() {
			// Apply css animation
			d3.select(this).classed("animated-dashoffset", true);

			// Fade out the shot path
			// The delay matches the duration of the CSS stroke-dashoffset animation
			d3.select(this).transition()
				.duration(400)
				.delay(1200)
				.ease(d3.easeQuadIn)
				.style("stroke-opacity", 0);
		});

	// Animate shot explosions and goal counts
	d3.selectAll("circle.shot").transition()
		.duration(250)
		.delay(function(d) {
			var delay = d.about.periodTime;
			for (var i = 0; i < d.about.period - 1; i++) {
				delay += periodDurations[i];
			}
			// Add offset for when explosion appears depending on shot type
			var offset = 600;
			var type = d.result.eventTypeId.toLowerCase();
			if (type === "missed_shot") {
				offset += 125;
			} else if (type === "goal") {
				offset += 100;
			} else if (type === "shot") {
				offset += 50;
			} else if (type === "blocked_shot") {
				offset += 0;
			}
			return offset + (delay * 1000) / 200;
		})
		.attr("r", function(d) {
			var type = d.result.eventTypeId.toLowerCase();
			if (type === "goal") {
				return 16;
			} else {
				return 3;
			}
		})
		.on("end", function(d) {
			// Fade out the explosion
			d3.select(this).transition()
				.delay(150)
				.duration(250)
				.attr("r", 0);
		})
		.on("start", function(d) {
			// Add bullet to shot tally
			var team = d.team.name.toLowerCase();
			if (team === teamData[0].name) {
				d3.select(".shot-tallies .away").append("span")
					.attr("class", "bullet");
			} else {
				d3.select(".shot-tallies .home").append("span")
					.attr("class", "bullet");
			}
			// Update score - exclude shootout goals
			var type = d.result.eventTypeId.toLowerCase();
			if (type === "goal") {
				var periodType = d.about.periodType.toLowerCase();
				if (periodType !== "shootout") {
					if (team === teamData[0].name) {
						score[0]++;
						d3.select(".away.header > .score").text(score[0]);
					} else {
						score[1]++;
						d3.select(".home.header > .score").text(score[1]);
					}
				}
			}
		});
}

function endGame() {
	console.log("Game ended!");

	// Update final score for SO
	if (isRegularSeason && periodDurations.length === 5) {
		var goalData = shotData.filter(function(d) { return d.result.eventTypeId.toLowerCase() === "goal"; });
		var aGoals = goalData.filter(function(d) { return d.team.name.toLowerCase() === teamData[0].name.toLowerCase(); }).length;
		var hGoals = goalData.filter(function(d) { return d.team.name.toLowerCase() === teamData[1].name.toLowerCase(); }).length;
		if (aGoals > hGoals) {
			score[0]++;
			d3.select(".away.header > .score").text(score[0]);
		} else if (hGoals > aGoals) {
			score[1]++;
			d3.select(".home.header > .score").text(score[1]);
		}
	}
}
</script>
</html>
