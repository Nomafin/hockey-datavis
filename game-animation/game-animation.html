<!DOCTYPE html>
<html lang="en">
<html>
<head>
	<meta charset="utf-8">
	<title>Game Animation</title>
	<script src="../d3.v4.min.js"></script>
	<link rel="stylesheet" type="text/css" href="game-animation.css">
</head>
<body style="padding: 40px;">
	<svg style="display: table;"></svg>
	<button style="margin: 20px 0; display: none;" onclick="animateGame();">Start animation</button>
</body>
<script>

//
// Data variables
//

// var gameId = 2016060108;
// var jsonUrl = "https://statsapi.web.nhl.com/api/v1/game/" + gameId + "/feed/live";
var jsonUrl = "live.json";
var teamData;
var shotData;
var periodDurations;

//
// Layout variables
//

var h = 120;
var w = 240;
var margin = { top: 0, right: 10, bottom: 0, left: 10 };
var barrierL = 60;						// Length of goalie and skater barriers
var y = h/2;							// Center of nets, goalie barriers, skater barriers
var netX = 25;							// Net's x-offset from svg edges
var goalieX = 40;						// Goalie barrier's x-offset from svg edges
var skaterX = 55;						// Skater barrier's x-offset from svg edges
var colour = ["red", "blue"];			// Colour class for away/home

//
// Prepare data
//

d3.json(jsonUrl, function(error, json) {
	if (error) {
		console.log(error);
		return;
	}

	// Store team and shot data
	teamData = [{
		abbr: json.gameData.teams.away.abbreviation.toLowerCase(),
		name: json.gameData.teams.away.name.toLowerCase(),
		colour: colour[0],
		nx: netX,
		gx: goalieX,
		sx: skaterX,
		y: y
	}, {
		abbr: json.gameData.teams.home.abbreviation.toLowerCase(),
		name: json.gameData.teams.home.name.toLowerCase(),
		colour: colour[1],
		nx: w - netX,
		gx: w - goalieX,
		sx: w - skaterX,
		y: y
	}];
	shotData = json.liveData.plays.allPlays.filter(function(d) {
		return ["blocked_shot", "missed_shot", "shot", "goal"].indexOf(d.result.eventTypeId.toLowerCase()) >= 0;
	});
	shotData.forEach(function(d) {
		d.about.periodTime = jsonTimeToSecs(d.about.periodTime);
		// For blocked shots, update the team
		var type = d.result.eventTypeId.toLowerCase();
		var team = d.team.name.toLowerCase();
		if (type === "blocked_shot" && team === teamData[0].name) {
			 d.team.name = teamData[1].name.toLowerCase();
		} else if (type === "blocked_shot" && team === teamData[1].name) {
			 d.team.name = teamData[0].name.toLowerCase();
		}
	});

	// Store period durations
	var periodData = json.liveData.plays.allPlays.filter(function(d) {
		return ["period_end"].indexOf(d.result.eventTypeId.toLowerCase()) >= 0;
	});
	periodDurations = periodData.map(function(d) {
		return jsonTimeToSecs(d.about.periodTime);
	});

	// Convert mm:ss to seconds
	function jsonTimeToSecs(timeStr) {
		var mins = parseInt(timeStr.substring(0, timeStr.indexOf(":")));
		var secs = parseInt(timeStr.substring(timeStr.indexOf(":") + 1));
		return 60 * mins + secs;
	}

	appendSvg();
});

//
// Append svg elements
//

function appendSvg() {
	var svg = d3.select("svg")
		.attr("width", w + margin.left + margin.right)
		.attr("height", h + margin.top + margin.bottom)
		.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	// Append goalie barrier
	svg.selectAll(".barrier-goalie")
		.data(teamData)
		.enter().append("line")
			.attr("class", function(d, i) {
				if (i === 0) {
					return "barrier-goalie away " + d.colour;
				} else {
					return "barrier-goalie home " + d.colour;
				}
			})
			.attr("x1", function(d) { return d.gx; })
			.attr("x2", function(d) { return d.gx; })
			.attr("y1", function(d) { return d.y - barrierL/2; })
			.attr("y2", function(d) { return d.y + barrierL/2; })

	// Append skater barrier
	svg.selectAll(".barrier-skater")
		.data(teamData)
		.enter().append("line")
			.attr("class", function(d, i) {
				if (i === 0) {
					return "barrier-skater away " + d.colour;
				} else {
					return "barrier-skater home " + d.colour;
				}
			})
			.attr("x1", function(d) { return d.sx; })
			.attr("x2", function(d) { return d.sx; })
			.attr("y1", function(d) { return d.y - barrierL/2; })
			.attr("y2", function(d) { return d.y + barrierL/2; })

	// Append group to hold shot elements
	var shotG = svg.append("g")
		.attr("class", "shots");

	// Append nets
	svg.selectAll("net")
		.data(teamData)
		.enter().append("path")
			.attr("class", function(d, i) {
				if (i === 0) {
					return "net away " + d.colour;
				} else {
					return "net home " + d.colour;
				}
			})
			.attr("d", function(d, i) {
				if (i === 0) {
					return "M" + teamData[0].nx + " " + y
						+ " L" + (teamData[0].nx - 12) + " " + (y - 8)
						+ " L" + (teamData[0].nx - 12) + " " + (y + 8)
						+ "Z";
				} else {
					return "M" + teamData[1].nx + " " + y
						+ " L" + (teamData[1].nx + 12) + " " + (y - 8)
						+ " L" + (teamData[1].nx + 12) + " " + (y + 8)
						+ "Z";				
				}
			});

	//
	// Generate and store shot paths
	//

	shotData.forEach(function(d) {
		var start = [];									// Where the shot starts
		var end = [];									// Where the shot ends
		var type = d.result.eventTypeId.toLowerCase();	// Shot type
		var team = d.team.name.toLowerCase(); 			// Team who took the shot

		// Get start and end points
		if (team === teamData[0].name) {
			start = [teamData[0].nx + 5, y];	// Shift shot start point to right to give some space between it and the net
			if (type === "goal") {
				end = [teamData[1].nx + 9, y];	// Shift shot end point to right to hit center of net
			} else if (type === "shot") {
				end[0] = teamData[1].gx;
				end[1] = y - (barrierL / 2) + (Math.random() * barrierL);
			} else if (type === "blocked_shot") {
				end[0] = teamData[1].sx;
				end[1] = y - (barrierL / 2) + (Math.random() * barrierL);
			} else if (type === "missed_shot") {
				end = [w + margin.right, Math.random() * h];
			}
		} else {
			start = [teamData[1].nx - 5, y];	// Shift shot start point to left to give some space between it and the net
			if (type === "goal") {
				end = [teamData[0].nx - 9, y];	// Shift shot end point to left to hit center of net
			} else if (type === "shot") {
				end[0] = teamData[0].gx;
				end[1] = y - (barrierL / 2) + (Math.random() * barrierL);
			} else if (type === "blocked_shot") {
				end[0] = teamData[0].sx;
				end[1] = y - (barrierL / 2) + (Math.random() * barrierL);
			} else if (type === "missed_shot") {
				end = [0 - margin.left, Math.random() * h];
			}
		}
		
		// Generate arc
		var end2 = [0, 0];
		end2[1] = Math.random() * (0.7 * h);						// Extent of y-deviation
		end2[1] = (Math.round(Math.random()) * 2 - 1) * end2[1];	// Randomize between positive and negative
		end2[1] = end2[1] + start[1];								// Add arc offset to original y value
		if (team === teamData[0].name) {
			end2[0] = start[0] + Math.random() * (end[0] - start[0]);
		} else {
			end2[0] = start[0] - Math.random() * (start[0] - end[0]);
		}

		d.path = "M" + start[0] + " " + start[1]
			+ " S" + end2[0] + " " + end2[1] + " " + end[0] + " " + end[1];
		d.end = end;
	});

	//
	// Append shot paths
	//

	shotG.selectAll("path.shot")
		.data(shotData)
		.enter().append("path")
			.attr("class", function(d) {
				var team = d.team.name.toLowerCase();
				if (team === teamData[0].name) {
					return "shot away " + teamData[0].colour;
				} else if (team === teamData[1].name) {
					return "shot home " + teamData[1].colour;
				}
			})
			.attr("d", function(d) {
				return d.path;
			})
			.style("stroke-opacity", 0);

	//
	// Append shot explosions
	//

	shotG.selectAll("circle.shot")
		.data(shotData.filter(function(d) { return d.result.eventTypeId.toLowerCase() !== "missed_shot"; }))
		.enter().append("circle")
			.attr("class", function(d) {
				var team = d.team.name.toLowerCase();
				if (team === teamData[0].name) {
					return "shot away " + teamData[0].colour;
				} else if (team === teamData[1].name) {
					return "shot home " + teamData[1].colour;
				}
			})
			.attr("r", 0)
			.attr("cx", function(d) {
				return d.end[0];
			})
			.attr("cy", function(d) {
				return d.end[1];
			})
			.style("stroke-width", function(d) {
				var type = d.result.eventTypeId.toLowerCase();
				if (type === "goal") {
					return 8;
				} else {
					return 0;
				}
			});

	// Activate button to start animation
	d3.select("button")
		.style("display", "");
}

//
// Animate svg
//

function animateGame() {

	// Disable start button
	d3.select("button")
		.attr("disabled", "disabled");

	// Animate shot paths
	d3.selectAll("path.shot").transition()
		.duration(50)
		.delay(function(d) {
			var delay = d.about.periodTime;
			for (var i = 0; i < d.about.period - 1; i++) {
				delay += periodDurations[i];
			}
			return (delay * 1000) / 200;
		})
		.style("stroke-opacity", 0.5)
		.on("start", function() {
			// Apply css animation
			d3.select(this).classed("animated-dashoffset", true);

			// Fade out the shot path
			// The delay matches the duration of the CSS stroke-dashoffset animation
			d3.select(this).transition()
				.duration(400)
				.delay(1200)
				.ease(d3.easeQuadIn)
				.style("stroke-opacity", 0);
		});

	// Animate shot explosions
	d3.selectAll("circle.shot").transition()
		.duration(250)
		.delay(function(d) {
			var delay = d.about.periodTime;
			for (var i = 0; i < d.about.period - 1; i++) {
				delay += periodDurations[i];
			}
			// Add offset for when explosion appears depending on shot type
			var offset = 900;
			var type = d.result.eventTypeId.toLowerCase();
			if (type === "goal") {
				offset += 100;
			} else if (type === "shot") {
				offset += 50;
			} else if (type === "blocked_shot") {
				offset += 0;
			}
			return offset + (delay * 1000) / 200;
		})
		.attr("r", function(d) {
			var type = d.result.eventTypeId.toLowerCase();
			if (type === "goal") {
				return 16;
			} else {
				return 3;
			}
		})
		.on("end", function() {
			// Fade out the explosion
			d3.select(this).transition()
				.delay(50)
				.duration(250)
				.attr("r", 0);
		});
}
</script>
</html>
